import{g as h,s as p,r as m}from"./many-CvjudpRv.js";function a(e){return new Promise((t,n)=>{e.oncomplete=e.onsuccess=()=>t(e.result),e.onabort=e.onerror=()=>n(e.error)})}function w(e,t){let n;const r=()=>{if(n)return n;const u=indexedDB.open(e);return u.onupgradeneeded=()=>u.result.createObjectStore(t),n=a(u),n.then(o=>{o.onclose=()=>n=void 0},()=>{}),n};return(u,o)=>r().then(s=>o(s.transaction(t,u).objectStore(t)))}let c;function i(){return c||(c=w("keyval-store","keyval")),c}function v(e,t=i()){return t("readonly",n=>a(n.get(e)))}function b(e,t,n=i()){return n("readwrite",r=>(r.put(t,e),a(r.transaction)))}function k(e,t=i()){return t("readwrite",n=>(n.delete(e),a(n.transaction)))}function d(e,t){return e.openCursor().onsuccess=function(){this.result&&(t(this.result),this.result.continue())},a(e.transaction)}function g(e=i()){return e("readonly",t=>{if(t.getAllKeys)return a(t.getAllKeys());const n=[];return d(t,r=>n.push(r.key)).then(()=>n)})}function A(e=i()){return e("readonly",t=>{if(t.getAll&&t.getAllKeys)return Promise.all([a(t.getAllKeys()),a(t.getAll())]).then(([r,u])=>r.map((o,s)=>[o,u[s]]));const n=[];return e("readonly",r=>d(r,u=>n.push([u.key,u.value])).then(()=>n))})}/*! byojs/Storage: adapter.idb.mjs
    v0.12.1 (c) 2025 Kyle Simpson
    MIT License: http://getify.mit-license.org
*/l.many=(...e)=>h(l,...e),y.many=(...e)=>p(y,...e),f.many=(...e)=>m(f,...e);var K="idb",j={storageType:"idb",has:S,get:l,set:y,remove:f,keys:g,entries:A};async function S(e){return(await g()||[]).includes(e)}async function l(e){return await v(e)??null}async function y(e,t){try{return await b(e,t!=null&&typeof t=="object"?t:String(t)),!0}catch(n){throw n.name=="QuotaExceededError"?new Error("IndexedDB storage is full.",{cause:n}):n}}async function f(e){return await k(e),!0}export{j as default,A as entries,l as get,S as has,g as keys,f as remove,y as set,K as storageType};
